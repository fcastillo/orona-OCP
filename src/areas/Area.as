/** * Gestión de area. * * @author: fer : 02/04/14 - 11:13 * @implements IArea */package areas{import components.AbstractComponent;import components.IComponent;import flash.display.MovieClip;import flash.display.Sprite;import utils.StringUtils;public class Area implements IArea{    private var _xPos:int = 0;    private var _yPos:int = 0;    private var _width:int = 0;    private var _height:int = 0;    private var _name:String = "";    private var _index:int = -1;  // índice de area 1,2,3,4    private var mask:Sprite;      // máscara del area    private var container:Sprite; // contenedor de componentes del area    private var componentsArray:Array = [];  // colección de componentes mostrados en el area    public function Area(name:String)    {        _name = name;    }    public function init():Sprite    {        container = new Sprite();        container.x = _xPos;        container.y = _yPos;        mask = new Sprite();        mask.x = _xPos;        mask.y = _yPos;        mask.graphics.beginFill(0xff0000);        mask.graphics.drawRect(0, 0, _width, _height);        mask.graphics.endFill();        container.mask = mask;        return container;    }    public function set x(xPos:int):void    {         _xPos = xPos;    }    public function get x():int    {         return _xPos;    }    public function set y(yPos:int):void    {         _yPos = yPos;    }    public function get y():int    {        return _yPos;    }    public function set width(w:int):void    {        _width = w;    }    public function get width():int    {        return _width;    }    public function set height(h:int):void    {        _height = h;    }    public function get height():int    {        return _height;    }    public function set index(i:int):void    {        _index = i;    }    public function get index():int    {        return _index;    }    /**     * Elimina todos los componentes del area que con "cleanables"     */    public function clear(forceAll:Boolean = false):void    {        if(forceAll)        {            destroyAll();        }        else        {            while(destroyCleanable())            {                destroyCleanable();            }        }    }    /**     * Marca los componentes susceptibles de ser eliminados en los     * cambios de estado.     *     * @param nextCompsData     */    public function setCleanables(nextComponentsData:XMLList, background:String):void    {        var len:uint = componentsArray.length;        for(var i:uint = 0; i < len; i++)        {            AbstractComponent(componentsArray[i]).cleanable = true;            var numComps:uint = nextComponentsData.length();            for(var j:uint = 0; j < numComps; j++)            {                if(i==0 && StringUtils.trim(background) != "")                {                    if(AbstractComponent(componentsArray[i]).equals(new XML("<img profundidad='0' path='"+background+"'/>")))                    {                        AbstractComponent(componentsArray[i]).cleanable = false;                    }                    break;                }else if(AbstractComponent(componentsArray[i]).equals(nextComponentsData[j]))                {                    AbstractComponent(componentsArray[i]).cleanable = false;                    break;                }            }        }    }    /**     * Elimina todos los componentes del area.     *     * @return     */    private function destroyAll():void    {        while(container.numChildren)        {            var child:AbstractComponent = container.getChildAt(0) as AbstractComponent;            child.destroy();            container.removeChildAt(0);        }        componentsArray = [];    }    /**     * Elimina sólo los componentes marcados como "cleanable".     *     * @return     */    private function destroyCleanable():Boolean    {        for(var i:uint = 0; i < componentsArray.length; i++)        {            var child:AbstractComponent = container.getChildAt(i) as AbstractComponent;            if(child.cleanable)            {                componentsArray.splice(i, 1);                container.removeChild(child);                child.destroy();                return true;            }        }        return false;    }    /**     * Devuelve todos los componentes registrados en el area.     *     * @return     */    public function getComponents():Array    {        return componentsArray;    }    /**     * Devuelve un componente por su id (type) para interactuar con él.     *     * @param id     * @return IComponent     */    public function getComponent(id:String):IComponent    {        for(var i:int = 0; i < componentsArray.length; i++)        {           if(componentsArray[i].type == id) return componentsArray[i];        }        return null;    }    /**     * Añade un componente al area.     *     * @param component     */    public function addComponent(comp:IComponent):void    {        if(!componentExists(AbstractComponent(comp))) componentsArray.push(comp);    }    /**     * Dibuja los componentes del area.     */    public function draw():void    {        componentsArray.sortOn("depth");        for(var i:int = 0; i < componentsArray.length; i++)        {            if(!componentAlreadyDrawn(componentsArray[i]))            {                componentsArray[i].init();                container.addChild(componentsArray[i]);            }        }        sortDisplayList();    }    private function sortDisplayList():void    {        var len:uint = container.numChildren;        var i,j;        for( i=0; i < len-1; i++ )        for (j=i+1; j < len; j++)        if ( IComponent(container.getChildAt(i)).depth > IComponent(container.getChildAt(j)).depth ) container.swapChildrenAt( i, j );    }    private function componentExists(comp:AbstractComponent):Boolean    {        for(var i:uint = 0; i < componentsArray.length; i++)        {            if(AbstractComponent(componentsArray[i]).equals(comp.data))            {                return true;            }        }        return false;    }    private function componentAlreadyDrawn(comp:IComponent):Boolean    {        var len:uint = container.numChildren;        for(var i:uint = 0; i < len; i++)        {            if(container.getChildAt(i) == comp) return true;        }        return false;    }}}