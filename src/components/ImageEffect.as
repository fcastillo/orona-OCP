/*** Efectos aplicados a las imágenes del pasafotos** @date 24/03/2014* @author fer*/package components{import com.greensock.TweenMax;import com.greensock.easing.Back;import com.greensock.easing.Bounce;import com.greensock.easing.Ease;import com.greensock.easing.Linear;import com.greensock.easing.Sine;import flash.display.Sprite;import flash.events.EventDispatcher;	public class ImageEffect extends EventDispatcher	{		// tipo de movimiento		private const NONE:String = "Ninguno";		private const VERTICAL:String = "Vertical";		private const HORIZONTAL:String = "Horizontal";        private var w:Number = 0;        private var h:Number = 0;		private var _effectMode:String = ""; // movimiento seleccionado		//				private var _delay:int = 1; // retardo entre transiciones		private var _speed:int = 1; // tiempo en segundos de la transición		private var _ease:String = ""; // tipo de frenado		private var _fromTo:String = ""; //toIzda, toDrcha, toUp, toDown				public function ImageEffect(w:Number, h:Number)		{			this.w = w;			this.h = h;			effectMode = NONE;		}				// Setters		public function set delay(value:int):void		{			_delay = value;		}				public function set speed(value:int):void		{			_speed = value;		}				public function set ease(value:String):void		{			_ease = value;		}				public function set fromTo(value:String):void		{			_fromTo = value;		}				public function set effectMode(value:String):void		{			_effectMode = value;		}		//        public function initSprite(sprite:Sprite):void        {            switch (_effectMode)            {                case NONE:                    sprite.alpha = 0;                    break;                case VERTICAL:                    sprite.y = _fromTo == "toUp" ? h: -h;                    break;                case HORIZONTAL:                    sprite.x = _fromTo == "toIzda" ? w: -w;                    break;            }        }		/**		 * Ejecuta el efecto de animación seleccionado		 * 		 * @param	image    Sprite a mover		 * @param	moveOut  Sacar de la vista		 */		public function applyEffect(sprite:Sprite, moveOut:Boolean = false):void		{			switch (_effectMode)			{				case NONE:                    moveOut ? fadeOut(sprite) : fadeIn(sprite);					break;				case VERTICAL:                     moveOut ? slideVOut(sprite) : slideVIn(sprite);					break;				case HORIZONTAL:                   // adjustHImageSize(image);                    moveOut ? slideHOut(sprite) : slideHIn(sprite);					break;			}		}        public function destroy():void        {            TweenMax.killDelayedCallsTo(onEffectInComplete);            TweenMax.killDelayedCallsTo(onEffectOutComplete);            //TweenMax.killAll();        }				/**		 * La imagen desaparece por fade out de transparencia		 * 		 * @param	image		 */		private function fadeOut(sprite:Sprite):void		{			TweenMax.to(sprite, _speed, {delay: _delay, alpha: 0, onStart: onEffectOutComplete, onStartParams: [sprite], ease: getEase()});		}				/**		 * La imagen aparece por fade in de transparencia		 * 		 * @param	image		 */		private function fadeIn(sprite:Sprite):void		{			TweenMax.to(sprite, _speed, {alpha: 1, onStart: onEffectInComplete, onStartParams: [sprite], ease: getEase()});		}				/**		 * La imagen se mueve en vertical y desaparece por fade out de transparencia		 * 		 * @param	image		 */		private function slideVOut(sprite:Sprite):void        {			TweenMax.to(sprite, _speed, {delay: _delay, alpha: 0, y: _fromTo == "toUp" ? -h: h, onStart: onEffectOutComplete, onStartParams: [sprite], ease: getEase()});		}				/**		 * La imagen se mueve en vertical		 * 		 * @param	image		 */		private function slideVIn(sprite:Sprite):void		{			TweenMax.to(sprite, 0, {alpha: 0});            sprite.y = _fromTo == "toUp" ? h: -h;			TweenMax.to(sprite, _speed, {alpha: 1, y: 0, onStart: onEffectInComplete, onStartParams: [sprite], ease: getEase()});		}				/**		 * La imagen se mueve en horizontal y desaparece por fade out de transparencia		 * 		 * @param	image		 */		private function slideHOut(sprite:Sprite):void		{			TweenMax.to(sprite, _speed, {delay: _delay, alpha: 0, x: _fromTo == "toIzda" ? -w : w, onStart: onEffectOutComplete, onStartParams: [sprite], ease: getEase()});		}				/**		 * La imagen se mueve en horizontal		 * 		 * @param	image		 * @param   otherImageWidth  Ancho de la otra imagen 		 */		private function slideHIn(sprite:Sprite):void		{			TweenMax.to(sprite, 0, {alpha: 0});            sprite.x = _fromTo == "toIzda" ? w: w;			TweenMax.to(sprite, _speed, {x: 0, alpha: 1, onStart: onEffectInComplete, onStartParams: [sprite], ease: getEase()});		}				private function onEffectOutComplete(sprite:Sprite):void		{            try{                if(_effectMode == NONE)                           {                               sprite.parent.swapChildrenAt(0, 1);                           }                           var event:ImageEffectEvent = new ImageEffectEvent(ImageEffectEvent.ON_EFFECT_OUT);                           event.sprite = sprite;                           dispatchEvent(event);            } catch(e:Error){}		}        private function onEffectInComplete(sprite:Sprite):void		{            try{                var event:ImageEffectEvent = new ImageEffectEvent(ImageEffectEvent.ON_EFFECT_IN);                            event.sprite = sprite;                            dispatchEvent(event);            }  catch(e:Error){}		}		private function getEase():Ease		{			switch (_ease)			{				case "easeInSine": 					return Sine.easeIn;					break;				case "easeOutSine": 					return Sine.easeOut;					break;				case "linear": 					return Linear.easeOut;					break;				case "easeOutBounce": 					return Bounce.easeOut;					break;				case "easeOutBack": 					return Back.easeOut;					break;				default: 					return Linear.easeNone;			}		}		}}